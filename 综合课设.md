#### TODO

网络应用层HTTP协议还原系统
编程实现针对HTTP协议的还原系统（重点实现功能）；学习使用Winpcap库的使用。
1、捕获网络数据包，并识别HTTP协议。
2、设计还原算法。
3、编程实现该算法。"
设计并在windows操作系统下编程实现该软件。
1、在windows操作系统实现。
2、实时计算网络异常连接。
3、安装winpcap库。
4、现场演示。

---

### 摘要

HTTP协议还原系统是一个用于捕获和还原网络中HTTP通信内容的工具。该系统的基本功能包括：捕获网络数据包，识别HTTP协议数据包，解析并还原HTTP协议内容。通过使用WinPcap库，系统能够在用户态应用程序中获取网络数据，并解析以太网帧、IP包和TCP包，以识别并提取HTTP协议数据。

本系统采用基于C语言和WinPcap库的面向对象技术实现了数据包捕获、协议解析和HTTP内容还原等各个模块。具体实现了数据包的捕获和过滤、HTTP请求和响应报文的解析，以及HTTP头部和正文的重组。同时，系统还优化了HTTP数据的输出和展示功能，以便于用户进行分析和查看。

通过本系统，用户能够方便地捕获并还原网络中的HTTP通信内容，为网络协议分析和数据挖掘提供了一个有效的工具。同时，系统的模块化设计使其具有良好的扩展性和可维护性，能够适应不断变化的网络环境和需求。

### 第一章、绪论

#### 1.1 HTTP协议介绍

在短短的二十几年时间里,万维网(Word Wide Web)从一种发布高能物理数据的方式演变为如今人们头脑中的因特网,它之所以如此流行是由于它有一个丰富多彩的界面,初学者很容易使用,并且提供了大量的信息资源,几乎涉及人们所能想象的所有主题。HTTP（超文本传输协议）在网络协议栈中位于应用层12。网络协议栈是一种用于实现网络通信的模型，它将网络通信的功能划分为不同的层次，每一层都有特定的功能和责任，并且通过接口和协议与其他层进行交互。以下是网络分层结构的简单介绍：

物理层：这一层负责在各种物理媒介上进行数据传输，为数据的传输提供可靠的环境。
数据链路层：数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧。
网络层：网络层负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。
运输层：运输层负责为两台主机中的进程提供通信服务。在TCP/IP体系中，这一层主要有两种协议：传输控制协议 (Transmission Control Protocol，TCP) 和用户数据报协议 (User Datagram Protocol，UDP)。
应用层：应用层是网络协议的最高层，主要任务通过进程间的交互完成特定网络应用。应用层协议定义的是应用程序（进程）间通信和交互的规则。
这种分层结构提供了灵活性、可扩展性和可维护性，使得不同厂商开发的设备能够互通和互操作。

##### 1.1.1HTTP协议发展历史

HTTP（HyperText Transfer Protocol）是万维网（World Wide Web）的基础协议。自蒂姆·伯纳斯·李博士和他的团队在1989-1991年间创造出它以来，HTTP已经发生了许多变化，在保持协议简单性的同时，不断扩展其灵活性。以下是HTTP协议的主要发展历程：

HTTP/0.9：这是HTTP的最初版本，被称为单行协议。它非常简单，请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径。响应也非常简单，只包含响应文档本身。
HTTP/1.0：这个版本主要是对0.9版本的强化，主要特性和缺点包括丰富的请求方法，增加了请求头和响应头的概念，扩充了传输内容格式包括图片、音视频资源、二进制等都可以进行传输。
HTTP/1.1：这个版本在1.0版本发布后大约1年就推出了，是对1.0版本的优化和完善，1.1版本的主要特点包括增加长连接，增加管线化技术，更多的请求方法，以及引入了额外的缓存控制机制。
HTTP/2.0：这个版本是个里程碑式的版本，相比1.x版本有了非常多的优化去适应当前的网络场景，其中几个重要功能点包括二进制格式，多路复用，头部压缩等。
HTTP/3.0：这是HTTP协议的最新版本，它进一步优化了HTTP协议的性能，提供了更高效的传输机制。

##### 1.1.2 HTTP报文

HTTP报文，也称为HTTP消息，是服务器和客户端之间交换数据的方式。HTTP报文主要分为两大类：请求报文和响应报文。

请求报文：由客户端发送给服务器，用来发起一个请求。请求报文由请求行、请求头部、空行和请求包体（body）组成。请求行主要描述了客户端想要如何操作服务端的资源，包括请求方法（如GET、POST等）、请求目标（通常是一个URL，表明了要操作的资源）和版本号（表示报文使用的HTTP协议版本）。请求头部包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。请求体就是HTTP要传输的内容，HTTP可以承载很多类型的数字数据:图片、音频、视频、HTML文档等。
响应报文：来自服务器的应答。响应报文由状态行、响应头部、空行和响应包体（body）组成。状态行包含了协议版本、状态码以及状态描述。响应头部和请求报文的请求头类似，响应头也由键值对组成，每行一对，键和值用英文冒号 : 分隔。响应包体是服务器返回给浏览器的响应信息，响应数据的格式是根据服务器来的，常见的响应数据格式有：text/html、application/json等。
HTTP报文是在HTTP应用程序之间发送的简单的格式化数据块。每条报文都包含一条来自客户端的请求，或者一条来自服务器的响应。它们由三个部分组成：对报文进行描述的起始行，包含属性的首部块，以及可选的、包含数据的主体部分。起始行和首部就是由行分隔的ASCII文本。

##### 1.2 winpcap介绍

大多数网络应用程序通过被广泛使用的操作系统原语来访 问网络，诸如sockets。操作系统已经处理了底层的细节问题（如协议处理，数据包的封装等），并提供与读写文 件类似的、熟悉的接口，这使得用该方法可以很容易的访问网络中的数据。然而有些时候，这种“简单的方式”并不能满足任务要求，因为有些应用程序需要直接访问网络中的数据包。也就是说，应用程序需要访问网络中的“原 始”数据包，即没有被操作系统使用网络协议进行处理过的数据包。WinPcap的目的就是为Win32应用程序提供这种访问方式。WinPcap提供下列功能：

- 捕获原始 数据包，无论是发送到运行*WinPcap机器上的数据包，还是在其它主机（* 共享介质 ）上进行交换的数据包
- 在数据包 分派给应用程序前，根据用户指定的规则过滤数据包
- 将原始数 据包发送到网络
- 收集网络流量的统计信息

Wincap有三部分组成：一个数据包监听设备驱动程序，一个低级的动态连接库和一个高级的静态连接库。数据包监听设备驱动程序直接从数据链路层取得网络数据包不加修改地传递给运行在用户层的应用程序，他在不同的WINDOWS系统下是不同。数据包监听设备驱动程序支持BPF过滤机制，可以灵活地设置过滤规则。低级的动态链接库运行在用户层，他把应用程序和数据包监听设备驱动程序隔离开来，使得应用程序可以不加修改地在不同的WINDOWS系统上运行。高级的静态链接库和应用程序编译在一起，他使用低级动态链接库提供的服务，向应用程序提供完善的监听接口。

### 第二章、系统分析

##### 2.1 功能分析

1. **捕获网络数据包**：通过使用WinPcap库，程序能够捕获网络数据包。WinPcap提供了底层网络访问接口，可以在用户态应用程序中访问网络数据。
2. **识别HTTP协议**：捕获的数据包中包含多种协议的数据，而本系统的目标是识别其中的HTTP协议数据包。这需要解析以太网帧、IP包以及TCP包，最终识别出HTTP协议的数据。
3. **还原HTTP协议内容**：在识别出HTTP协议数据后，系统将解析HTTP头部和正文内容，并将其分离和重组，提供对HTTP通信的完整还原。

##### 2.2 系统框架

1. **数据包捕获模块**：利用WinPcap库捕获网络数据包，并保存原始数据包信息。
2. **协议解析模块**：对捕获的网络数据包进行解析，提取以太网、IP、TCP/UDP和HTTP协议头部信息。
3. **HTTP还原模块**：对解析后的HTTP数据进行重组，提取HTTP头部和正文内容，并进行分类处理。
4. **输出模块**：将还原的HTTP信息输出到终中，便于分析和查看。

### 第三章、详细设计及实现

#### 3.1 设计

1. **数据包捕获模块设计**
   - 初始化WinPcap库，并获取所有网络接口。
   - 用户选择一个网络接口进行数据包捕获。
   - 打开选定的网络接口，设置捕获参数（例如：混杂模式，超时时间）。
   - 开始捕获数据包，并将数据包传递给协议解析模块。
2. **协议解析模块设计**
   - 解析以太网帧头部，提取以太网类型。
   - 解析IP包头部，主要提取协议类型信息。
   - 解析TCP包头部，提取源端口、目的端口、序列号、确认号等信息。
   - 识别并提取HTTP协议数据，判断是请求还是响应。
3. **HTTP还原模块设计**
   - 解析HTTP头部信息，提取HTTP方法、URL、状态码等。
   - 识别HTTP头部与正文的分隔符，分离头部和正文。
   - 根据Content-Type对正文内容进行处理（如：文本直接输出）。
4. **输出模块设计**
   - 将HTTP头部和正文信息格式化输出到终端。

#### 3.2 实现

##### 3.2.1 API

**winpcap API**

**pcap--Packet Capture**

`pcap_findalldevs_ex`：该函数用于获取所有的网络设备列表。它返回一个包含所有网络设备的链表。

```c
int pcap_findalldevs_ex(char *source, struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf);
```

- `source`：数据源的名称。这是一个字符串，用于指定数据包捕获的源。例如，它可以是一个网络接口的名称，或者是一个保存了网络数据包的文件的路径。查找本地的网路设备，填写`PCAP_SRC_IF_STRING`

  ```c
  #define PCAP_SRC_IF_STRING "rpcap://"
  ```

- `auth`：远程认证参数，一般填NULL

-   `alldevs`：返回的设备列表。

  ```c
  struct pcap_if {
  	struct pcap_if *next;
  	char *name;		/* name to hand to "pcap_open_live()" */
  	char *description;	/* textual description of interface, or NULL */
  	struct pcap_addr *addresses;
  	bpf_u_int32 flags;	/* PCAP_IF_ interface flags */
  };
  ```

- `errbuf`：错误信息。

**返回值**：如果成功，返回0；如果失败，返回-1。



`pcap_freealldevs`：这个函数用于释放设备列表。在你选择了一个设备并打开它之后，就可以释放设备列表了。

```c
void pcap_freealldevs(pcap_if_t *);
```

- `alldevs`：设备列表。

**无返回值**



`pcap_open`：这个函数用于打开一个网络设备进行数据包捕获。

```c
pcap_t *pcap_open(const char *device, int snaplen, int promisc, int to_ms, char *errbuf);
```

- `device`：设备的名称。
- `snaplen`：要保留的数据包长度。
- `promisc`：是否启用混杂模式。
- `to_ms`：读取超时时间。
- `errbuf`：错误信息。

**返回值**：如果成功，返回设备的描述符；如果失败，返回NULL。



`pcap_next_ex`：这个函数用于获取下一个数据包。它返回下一个数据包的头部和数据。

**Packet Capture Next Extended**

```c
int pcap_next_ex(pcap_t *p, struct pcap_pkthdr **pkt_header, const u_char **pkt_data);
```

- `p`：设备的描述符。这是一个指向pcap_t类型的指针。pcap_t是一个结构体，表示一个打开的数据包捕获实例。这个结构体是不透明的，用户通过wpcap.dll提供的函数来处理其内容。

- `pkt_header`：返回的数据包头部。

  ```c
  struct pcap_pkthdr {
  	struct timeval ts;	/* time stamp */
  	bpf_u_int32 caplen;	/* length of portion present */
  	bpf_u_int32 len;	/* length this packet (off wire) */
  };
  ```

- `pkt_data`：返回的数据包数据。一个指向`u_char`类型的指针。数据包的数据部分**以链路层头开始**。链路层头的格式由pcap_datalink函数的返回值指示。

**返回值**：如果成功，返回1；如果超时，返回0；如果错误，返回-1；如果达到EOF，返回-2。



**其他API**

**`ntohs`**

```c
uint16_t ntohs(uint16_t netshort);
```

`ntohs`函数全称是"Network TO Host Short"，用于将一个16位数由网络字节顺序转换为主机字节顺序

在网络通信中，为了保证数据的正确传输，需要统一数据的字节顺序。网络字节顺序通常是大端顺序（Big-Endian），也就是高位字节在前，低位字节在后。然而，不同的机器可能采用不同的字节顺序，例如Intel处理器就采用小端顺序（Little-Endian），即低位字节在前，高位字节在后。因此，在发送数据时，主机需要将数据从主机字节顺序转换为网络字节顺序，接收数据时，又需要将数据从网络字节顺序转换回主机字节顺序。



**`localtime()`**

```c
struct tm *localtime(const time_t *timer)
```

使用 `timer` 的值来填充 **tm** 结构。**timer** 的值被分解为 **tm** 结构，并用本地时区表示。

- **timer** -- 这是指向表示日历时间的 time_t 值的指针。

返回值：返回指向 **tm** 结构的指针，该结构带有被填充的时间信息。下面是 tm 结构的细节：

```
struct tm {
   int tm_sec;         /* 秒，范围从 0 到 59                */
   int tm_min;         /* 分，范围从 0 到 59                */
   int tm_hour;        /* 小时，范围从 0 到 23                */
   int tm_mday;        /* 一月中的第几天，范围从 1 到 31                    */
   int tm_mon;         /* 月份，范围从 0 到 11                */
   int tm_year;        /* 自 1900 起的年数                */
   int tm_wday;        /* 一周中的第几天，范围从 0 到 6                */
   int tm_yday;        /* 一年中的第几天，范围从 0 到 365                    */
   int tm_isdst;       /* 夏令时                        */    
};
```



**`strftime()`**

```c
size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)
```

- **str** -- 这是指向目标数组的指针，用来复制产生的 C 字符串。
- **maxsize** -- 这是被复制到 str 的最大字符数。
- **format** -- 这是 C 字符串，包含了普通字符和特殊格式说明符的任何组合。这些格式说明符由函数替换为表示 tm 中所指定时间的相对应值。

- **timeptr** -- 这是指向 tm 结构的指针，该结构包含了一个被分解为以下各部分的日历时间。

返回值：如果产生的 C 字符串小于 size 个字符（包括空结束字符），则会返回复制到 str 中的字符总数（不包括空结束字符），否则返回零。



##### 3.2.2 结构体

一些重要的类型，需要自己在代码中进行定义。

**以太网帧头部**

![image-20240513200708824](C:/Users/PannLZ/AppData/Roaming/Typora/typora-user-images/image-20240513200708824.png)

- **源地址**：长度为**6**字节，用于标记数据由哪台机器发送。
- **目标地址**：长度为**6**字节，用于标记数据由哪台机器接收。
- **类型**：长度为**2**字节，用于标记数据该如何处理，例如，**0x0800表示该帧数据是一个IP包**。

```c
typedef struct ether_header {
    u_char ether_shost[ETHER_ADDR_LEN]; /* source ethernet address, 8 bytes */
    u_char ether_dhost[ETHER_ADDR_LEN]; /* destination ethernet addresss, 8 bytes */
    u_short ether_type;                 /* ethernet type, 16 bytes */
}ether_header;
```



**IP头部**（IPv4）

<img src="C:/Users/PannLZ/AppData/Roaming/Typora/typora-user-images/image-20240513200510243.png" alt="image-20240513200510243" style="zoom:67%;" />

- **版本**：占4位，指IP协议的版本。
- **头部长度**：占4位，描述IP包头的长度，因为在IP包头中有变长的可选部分。
- **服务类型**：占8位，在一般情况下都不使用这个字段。
- **总长度**：表示报头和数据之和的长度，单位是字节。
- **标识**：占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并赋给标识字段。
- **标志**：占3位，表示包被分片的相关信息。
- **片偏移**：占13位。表示该IP包在该组分片包中位置，接收端靠此来组装还原IP包。
- **生存时间（TTL）**：占8位。表示数据报在网络中的寿命。
- **协议**：占8位，指出此数据报中所包含的上层协议类型，如TCP、UDP等。
- **头部校验和**：占16位，该字段只校验数据报的报头，但不包括数据部分。
- **源IP地址**：占32位，指定发送方的IP地址。
- **目的IP地址**：占32位，指定接收方的IP地址。
- **选项**

```c
typedef struct ip_header {
    u_char ver_ihl;         /* version and ip header length */
    u_char tos;             /* type of service */
    u_short tlen;           /* total length */
    u_short identification; /* identification */
    u_short flags_fo;       // flags and fragment offset
    u_char ttl;             /* time to live */
    u_char proto;           /* protocol */
    u_short crc;            /* header checksum */
    ip_address saddr;       /* source address */
    ip_address daddr;       /* destination address */
    u_int op_pad;           /* option and padding */
}ip_header;
```

​	

**TCP头部**

<img src="C:/Users/PannLZ/AppData/Roaming/Typora/typora-user-images/image-20240513200334051.png" alt="image-20240513200334051" style="zoom: 67%;" />

- **源端口**：占16位，表示报文发送方的端口号。
- **目标端口**：占16位，表示报文接收方的端口号。
- **序号**：占32位，一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。
- **确认号**：占32位，用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。
- **头部长度**：占4位，表示tcp头部有多少个32bit字（4字节）。
- **标志位**：占6位，包括URG（紧急指针是否有效），ACK（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）等。
- **窗口大小**：占16位，是TCP流量控制的一个手段。它告诉对方本段的TCP接收缓冲区的大小，单位一般是字节。
- **校验和**：占16位，由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。
- **紧急指针**：占16位，一个正的偏移量，仅在URG标志位开启时有效。

```c
typedef struct tcp_header {
    u_short th_sport;         /* source port */
    u_short th_dport;         /* destination port */
    u_int th_seq;             /* sequence number */
    u_int th_ack;             /* acknowledgement number */
    u_short th_len_resv_code; /* datagram length and reserved code */
    u_short th_window;        /* window */
    u_short th_sum;           /* checksum */
    u_short th_urp;           /* urgent pointer */
}tcp_header;
```

HTTP会话

```c
struct http_session {
    char header[4096];
    char body[4096];
};
```

##### 3.2.3 模块实现

1. **数据包捕获模块实现**

   ```c
   c复制代码pcap_if_t* alldevs;
   pcap_if_t* d;
   int inum;
   int i = 0;
   char errbuff[PCAP_ERRBUF_SIZE];
   pcap_t* adhandle;
   
   // 获取所有设备列表
   if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuff) == -1) {
       fprintf(stderr, "Error in pcap_findalldevs: %s\n", errbuf);
       exit(1);
   }
   
   // 列出所有设备
   for (d = alldevs; d; d = d->next) {
       printf("%d. %s", ++i, d->name);
       if (d->description)
           printf(" (%s)\n", d->description);
       else
           printf(" (No description available)\n");
   }
   
   // 用户选择设备
   printf("Enter the interface number (1-%d):", i);
   scanf("%d", &inum);
   for (d = alldevs, i = 0; i < inum - 1; d = d->next, i++);
   
   // 打开设备
   if ((adhandle = pcap_open(
       d->name, 
       65536,
       PCAP_OPENFLAG_PROMISCUOUS,
       1000, 
       NULL, 
       errbuf
   )) == NULL) {
       fprintf(stderr, "\nUnable to open the adapter. %s is not supported by WinPcap\n", d->name);
       pcap_freealldevs(alldevs);
       return -1;
   }
   printf("\nlistening on %s...\n", d->description);
   
   pcap_freealldevs(alldevs);
   ```

2. **协议解析模块实现**

   ```c
   c复制代码struct ether_header* eh = (struct ether_header*)pkt_data;
   
   // 解析以太网帧
   if (ntohs(eh->ether_type) == 0x0800) {
       struct ip_header* ih = (struct ip_header*)(pkt_data + 14);
       
       // 解析IP包
       if (ntohs(ih->proto) == 0x0600) {
           int ip_len = ntohs(ih->tlen);
           char* ip_pkt_data = (char*)ih;
   
           // 识别HTTP协议
           for (int i = 0; i < ip_len; ++i) {
               if (!find_http && (i + 3 < ip_len && strncmp(ip_pkt_data + i, "GET ", strlen("GET ")) == 0)
                   || (i + 4 < ip_len && strncmp(ip_pkt_data + i, "POST ", strlen("POST ")) == 0)) {
                   find_http = 1;
               }
               if (!find_http && i + 8 < ip_len && strncmp(ip_pkt_data + i, "HTTP/1.1 ", strlen("HTTP/1.1 ")) == 0) {
                   find_http = 1;
               }
               if (find_http && is_readable(ip_pkt_data[i])) {
                   strncat(http_txt, &ip_pkt_data[i], 1);
               }
           }
   
           if (strcmp(http_txt, "") != 0) {
               struct http_session session;
               parse_http(http_txt, &session);
               print_http(&session);
           }
       }
   }
   ```

3. **HTTP还原及输出模块实现**

   ```c
   void parse_http(char* http_txt, struct http_session* session) 
   {
       char* separator = strstr(http_txt, "\r\n\r\n");
       if (separator) {
           strncpy(session->header, http_txt, separator - http_txt);
           session->header[separator - http_txt] = '\0';
           strcpy(session->body, separator + 4);
       } else {
           strcpy(session->header, http_txt);
           session->body[0] = '\0';
       }
   }
   
   void print_http(struct http_session* session) 
   {
       printf("Header: \n%s\n", session->header);
       char* content_type = strstr(session->header, "Content-Type: ");
       if (content_type) {
           content_type += strlen("Content-Type: ");
           char* end = strchr(content_type, '\r');
           if (end) {
               *end = '\0';
           }
           if (strncmp(content_type, "text/html", strlen("text/html")) == 0 ||
               strncmp(content_type, "text/css", strlen("text/css")) == 0 ||
               strncmp(content_type, "application/json", strlen("application/json")) == 0 ||
               strncmp(content_type, "application/xml", strlen("application/xml")) == 0) {
               printf("Body: \n%s\n", session->body);
           } else {
               printf("Body: \n");
               for (int i = 0; session->body[i] != '\0'; ++i) {
                   printf("%02x ", (unsigned char)session->body[i]);
               }
               printf("\n");
           }
           if (end) {
               *end = '\r';
           }
       } else {
           printf("Body: \n%s\n", session->body);
       }
   }
   ```

至此，可以完成网络数据包捕获、协议解析及HTTP数据还原的系统，达到对HTTP通信进行监控和分析的目标。

> 注意：需要在源代码开始加上#define WIN32

### 第四章、测试

#### 环境配置

##### winpcap库安装

使用 WinPcap 必须安装其软件以及获取对应的 DLL、底层库。

#####  vs2022 环境配置

在项目设置中，选择 C/C++ -> 预处理器，在预处理器定义中添加 `WPCAP `和 `HAVE_REMOTE `两个宏定义，然后点击应用；选择 链接器 -> 输入，在附加依赖项添加` wpcap.lib` 、` ws2_32.lib` 、` Packet.lib` 三个库，然后点击应用；选择 VC++ 目录，添加 `WpdPack` 文件夹中的包含目录（ include 目录），然后点击应用；选择 VC++ 目录，添加` WpdPack` 文件夹中的库目录（ Lib 目录），然后点击应用；

**生成解决方案**

点击生成解决 方案，可以得到exe可执行文件。

##### 运行结果

![image-20240514154020437](C:/Users/PannLZ/AppData/Roaming/Typora/typora-user-images/image-20240514154020437.png)

![image-20240514155557182](C:/Users/PannLZ/AppData/Roaming/Typora/typora-user-images/image-20240514155557182.png)

![image-20240514155822597](C:/Users/PannLZ/AppData/Roaming/Typora/typora-user-images/image-20240514155822597.png)



![image-20240514212820863](C:/Users/PannLZ/AppData/Roaming/Typora/typora-user-images/image-20240514212820863.png)



参考文献：

[1] 谢希仁.计算机网络[M].北京：电子工业出版社 2005.6

[2]WinPcap 中文技术文档[WinPcap: WinPcap 中文技术文档 (redicecn.com)](http://www.redicecn.com/htdocs/WinPcap Document V4.01/docs_cn/html/main.html#:~:text=什么是WinPcap 1 捕获原始数据包，无论它是发往某台机器的，还是在其他设备（共享媒介）上进行交换的 2,在数据包发送给某应用程序前，根据用户指定的规则过滤数据包 3 将原始数据包通过网络发送出去 4 收集并统计网络流量信息)

[3] [网络基础-应用层协议-HTTP/HTTPS-CSDN博客](https://blog.csdn.net/Djsnxbjans/article/details/132905766)

[4] [WinPcap网络编程入门——0. 环境配置及系列介绍_winpcap开发教程-CSDN博客](https://blog.csdn.net/weixin_46117139/article/details/122635095)

[5] [应用层HTTP数据包的截获与还原技术的实现_捕获还原功能-CSDN博客](https://blog.csdn.net/qq_29312157/article/details/51232318)
